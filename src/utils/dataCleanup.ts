// Data cleanup utility for form submissions
// Ensures data is properly formatted before sending to database

export interface CleanupOptions {
  removeEmptyStrings?: boolean;
  removeNullValues?: boolean;
  removeUndefinedValues?: boolean;
  convertEmptyToNull?: boolean;
}

export function cleanFormData(data: any, options: CleanupOptions = {}): any {
  const {
    removeEmptyStrings = true,
    removeNullValues = false,
    removeUndefinedValues = true,
    convertEmptyToNull = true
  } = options;

  const cleaned: any = {};

  for (const [key, value] of Object.entries(data)) {
    // Skip if value is undefined and we're removing undefined values
    if (value === undefined && removeUndefinedValues) {
      continue;
    }

    // Skip if value is null and we're removing null values
    if (value === null && removeNullValues) {
      continue;
    }

    // Skip if value is empty string and we're removing empty strings
    if (value === '' && removeEmptyStrings) {
      continue;
    }

    // Convert empty strings to null for specific field types
    if (convertEmptyToNull && value === '') {
      // Date fields should be null if empty
      if (isDateField(key)) {
        continue; // Skip the field entirely
      }
      
      // Numeric fields should be null if empty
      if (isNumericField(key)) {
        continue; // Skip the field entirely
      }
    }

    cleaned[key] = value;
  }

  return cleaned;
}

function isDateField(fieldName: string): boolean {
  const dateFields = [
    'date_of_birth',
    'director_date_of_birth',
    'chairman_date_of_birth',
    'secretary_date_of_birth',
    'treasurer_date_of_birth',
    'established_date',
    'created_at',
    'updated_at'
  ];
  
  return dateFields.some(field => fieldName.toLowerCase().includes(field.toLowerCase()));
}

function isNumericField(fieldName: string): boolean {
  const numericFields = [
    'spouse_monthly_earnings',
    'monthly_income',
    'net_monthly_salary',
    'average_monthly_income',
    'years_of_employment',
    'group_size',
    'total_loans_repaid'
  ];
  
  return numericFields.some(field => fieldName.toLowerCase().includes(field.toLowerCase()));
}

// Specific cleanup for client data
export function cleanClientData(data: any): any {
  // First clean the data
  let cleaned = cleanFormData(data, {
    removeEmptyStrings: true,
    removeNullValues: false,
    removeUndefinedValues: true,
    convertEmptyToNull: true
  });

  // Remove computed fields that are generated by database trigger
  delete cleaned.full_name;
  delete cleaned.contact_person_name;
  delete cleaned.group_leader_name;

  // Remove system fields that should be handled by database
  delete cleaned.created_at;
  delete cleaned.updated_at;

  // Remove fields that don't exist in the clients table
  const fieldsToRemove = [
    'bank_account_number', // Use account_number instead
    'bank_statement_uploaded',
    'national_id_document_uploaded',
    'national_id_document_url',
    'bank_statement_url',
    'search_vector',
    'profile_id',
    'alternative_phone',
    'application_id',
    'id_document_uploaded',
    'passport_photo_uploaded',
    'fingerprint_uploaded',
    'salary_slip_uploaded'
  ];

  fieldsToRemove.forEach(field => {
    delete cleaned[field];
  });

  // Fix gender field - only send valid values, default to 'male' if invalid
  if (!cleaned.gender || !['male', 'female', 'other'].includes(cleaned.gender.toLowerCase())) {
    cleaned.gender = 'male'; // Default to 'male' if invalid or empty
  }

  // Fix other gender fields - only send valid values, default to 'male' if invalid
  const genderFields = ['director_gender', 'chairman_gender', 'secretary_gender', 'treasurer_gender'];
  genderFields.forEach(field => {
    if (!cleaned[field] || !['male', 'female', 'other'].includes(cleaned[field].toLowerCase())) {
      cleaned[field] = 'male'; // Default to 'male' if invalid or empty
    }
  });

  // Fix marital_status field - only send valid values
  if (cleaned.marital_status && !['single', 'married', 'divorced', 'widowed'].includes(cleaned.marital_status.toLowerCase())) {
    delete cleaned.marital_status;
  }

  // Fix client_type field - only send valid values, default to 'individual' if invalid
  if (!cleaned.client_type || !['individual', 'corporate', 'group'].includes(cleaned.client_type.toLowerCase())) {
    cleaned.client_type = 'individual'; // Default to 'individual' if invalid or empty
  }

  // Fix client_category field - only send valid values, default to 'new' if invalid
  if (!cleaned.client_category || !['new', 'existing'].includes(cleaned.client_category.toLowerCase())) {
    cleaned.client_category = 'new'; // Default to 'new' if invalid or empty
  }

  // Fix status field - only send valid values, default to 'active' if invalid
  if (!cleaned.status || !['active', 'inactive', 'suspended', 'archived'].includes(cleaned.status.toLowerCase())) {
    cleaned.status = 'active'; // Default to 'active' if invalid or empty
  }

  // Fix kyc_status field - only send valid values, default to 'pending' if invalid
  if (!cleaned.kyc_status || !['pending', 'verified', 'rejected'].includes(cleaned.kyc_status.toLowerCase())) {
    cleaned.kyc_status = 'pending'; // Default to 'pending' if invalid or empty
  }

  // Fix risk_level field - only send valid values, default to 'low' if invalid
  if (!cleaned.risk_level || !['low', 'medium', 'high'].includes(cleaned.risk_level.toLowerCase())) {
    cleaned.risk_level = 'low'; // Default to 'low' if invalid or empty
  }

  // Fix employment_status field - only send valid values
  if (cleaned.employment_status && !['employed', 'self_employed', 'unemployed', 'retired', 'student', 'other'].includes(cleaned.employment_status.toLowerCase())) {
    delete cleaned.employment_status;
  }

  return cleaned;
}
